# 14.1 변수의 생명주기

#### 변수의 생명주기
- 변수는 선언에 의해 생성되고 할당을 통해 값을 받고 사용이 끝나면 소멸한다.
- 변수는 자신이 등록된 스코프가 소멸할 때 까지 유효하다
- 변수의 생명주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다.
<br>

#### 지역변수의 생명주기
- 지역 변수의 생명주기는 함수의 생명주기와 일치한다.<br>
- 함수안에서 생성된 지역 변수는 함수가 생성한 스코프에 등록된다.


    function foo() {
        // 변수 x 생성, 값 할당
        var x = 'local'
        console.log(x)
        return x
        // 변수 x 소멸
    }
<br>

#### 전역변수의 생명주기
- 전역변수는 런타임 이전 단계에서부터 생성된다.
- 지역변수와는 달리 특별한 진입점이 없고 마지막 문이 실행되어 더 이상 실행할 문이 없을 때, 어플리케이션과 같이 사라진다
- var 키워드로 생성한 전역변수는 전역 객체에 속하게 되며, 전역객체의 생명주기와 일치한다. <br>
    ex) 브라우저 : window



# 14.2 전역 변수의 문제점
- 암묵적 결합
  - 모든 코드가 전역 변수를 참조하여 변경할 수 있는 것을 암묵적 결합이라고 한다.
  - 코드유효 범위가 클수록 가독성이 나빠지고, 의도치 않게 상태가 변경될 수 있다.
 
- 생명주기가 길다 
  - 메모리 리소스를 오랜 기간 소비한다 따라서, 전역 변수의 상태를 변경할 시간과 기회가 많다.
  - var 키워드로 선언 했다면 재할당 가능성이 있어서 상태가 변경될 가능성이 다분하다 = 안정적이지 않다.

- 전역 변수는 검색이 가장 느리다
  - 스코프 체인상에서 가장 윗단에 있기 때문에 거슬러 올라가야하기 때문이다.

- 네임스페이스 오염
  <br>자바스크립트는 파일이 분리되어 있어도 하나의 전역스코프를 공유한다. 
  <br>만약 다른 파일에서 동일한 이름의 전역 변수나 함수가 존재한다면, 서로 꼬일 우려가 크다.

# 14.3 전역 변수 사용 억제법
- 즉시 실행 함수<br>
    즉시 실행 함수로 감싸서 전역 변수의 사용을 제한한다.

        (function (){
            var foo = 10 // 즉시 실행함수니까 지역변수가 된다.
        }())

        console.log(foo)


- 모듈패턴
    - 클래스를 모방해서 관련있는 함수나 변수를 함수로 감싼다
      - 모듈 패턴의 특징은 전역 변수 억제와 캡슐화까지 구현가능하다
    

    var Counter = (function () {

        // private 변수
        var num = 0
        return {
            increase() {
                return ++num
            },
          decrease() {
              return --num
          }
        }
    }())

    console.log(Counter.num)   // private에는 접근 불가
    console.log(Counter.increase())
    console.log(Counter.increase())
    console.log(Counter.decrease())
    console.log(Counter.decrease())


- ES6 모듈
  - 모듈을 사용하면 전역 변수를 사용할 수 없다.
  - ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.